    冒泡排序（Bubble Sort）
    优点：实现简单易懂，代码简单，适用于数据规模较小的情况。
    缺点：时间复杂度较高，当数据规模很大时，排序时间会很长，不适用于大规模数据的排序。
    应用场景：适用于数据规模较小且实现简单的排序场景，例如学生成绩排名等。

    选择排序（Selection Sort）
    优点：实现简单，适用于数据规模较小的情况。
    缺点：时间复杂度较高，与冒泡排序一样，不适用于大规模数据的排序。
    应用场景：适用于数据规模较小且实现简单的排序场景，例如对个人存款进行排序等。

    插入排序（Insertion Sort）
    优点：实现简单，适用于数据规模较小的情况。
    缺点：时间复杂度较高，不适用于大规模数据的排序。
    应用场景：适用于数据规模较小的排序场景，例如扑克牌的排序等。

    希尔排序（Shell Sort）
    优点：相对于前面几种排序，时间复杂度有较大优化，适用于数据规模较大的排序。
    缺点：实现较为复杂，不如快速排序和归并排序简洁易懂。
    应用场景：适用于数据规模较大的排序场景，例如大型数据库排序等。

    快速排序（Quick Sort）
    优点：时间复杂度较低，效率高，是常用的排序方法之一。
    缺点：实现过程比较复杂，容易出错，而且最坏情况下时间复杂度较高。
    应用场景：适用于数据规模较大的排序场景，例如大型数据库排序等。

    归并排序（Merge Sort）
    优点：时间复杂度较低，效率高，是常用的排序方法之一。
    缺点：实现过程比较复杂。
    应用场景：适用于数据规模较大的排序场景，例如大型数据库排序等。

    堆排序（Heap Sort）
    优点：时间复杂度较低，效率高，是常用的排序方法之一。
    缺点：实现过程比较复杂。
    应用场景：适用于数据规模较大的排序场景，例如大型数据库排序等。

    计数排序（Counting Sort）
    优点：时间复杂度较低，效率高。
    缺点：只适用于正整数排序，且数据范围不能太大。
    应用场景：适用于数据范围较小且数据类型为正整数的排序场景，例如年龄排序等。
    
    基数排序（Radix Sort）：
    优点：稳定性好，适用于大量数据的排序，效率较高。
    缺点：占用较大的内存空间。
    应用场景：适用于大量数据的排序，例如大量数字的排序，身份证号码排序等。
